
# Architecture Strategy: Database & Backend

Currently, **Governance Builder** runs entirely on the client-side using `localStorage`. To support multi-user collaboration, Google SSO, and robust data persistence as requested, we will transition to a **Cloud-Native Serverless Architecture** using **Firebase Firestore**.

This approach allows us to keep the application lightweight (perfect for your AWS EC2 t3.micro deployment) while delegating database management, security, and scaling to Google Cloud.

---

## 1. Technology Choice: Cloud Firestore (NoSQL)

We have chosen Firestore for the following reasons:
*   **Seamless Integration**: Works natively with the Google Auth we just implemented.
*   **JSON-like Structure**: Perfect for storing dynamic "Taxonomy DNA" and Dictionaries which vary in structure.
*   **Real-time Updates**: Changes made by an Admin (e.g., adding a new dictionary value) can propagate instantly to Planners without refreshing.
*   **Zero Maintenance**: No need to install or patch a database server on your EC2 instance.

---

## 2. Data Modeling (Schema)

We will structure the database into the following core collections:

### A. `users` (Collection)
Stores user profiles and roles.
```json
{
  "uid": "google_uid_123",
  "email": "planner@agency.com",
  "name": "Jane Doe",
  "role": "planner", // 'admin' | 'planner' | 'trafficker'
  "createdAt": "timestamp"
}
```

### B. `tenants` (Collection - The Organization)
Top-level grouping for multi-tenant support.
```json
{
  "id": "tenant_001",
  "name": "Global Agency Inc",
  "settings": { ... }
}
```

### C. `clients` (Sub-collection of Tenants)
Clients belong to a specific tenant.
`tenants/{tenantId}/clients/{clientId}`
```json
{
  "id": "client_nike",
  "name": "Nike",
  "code": "NKE",
  "settings": {
     "separators": ["_", "-"],
     "casing": "UPPERCASE"
  }
}
```

### D. `dictionaries` (Collection)
The "DNA" segments shared globally or per-tenant.
```json
{
  "id": "country_code",
  "name": "Country",
  "values": ["US", "UK", "MX", "BR"],
  "mappings": {
    "campaign": true,
    "adset": false
  }
}
```

### E. `taxonomies` (Collection)
The actual naming conventions generated by Planners/Traffickers.
```json
{
  "id": "tax_999",
  "generatedName": "US_BRAND_AWARENESS_2024",
  "components": { "country": "US", "objective": "AWARENESS" },
  "createdBy": "user_uid",
  "status": "draft" // or 'finalized'
}
```

---

## 3. Security & Governance (Firestore Rules)
We will enforce Governance not just in the UI, but at the database level:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Rules
    match /dictionaries/{document} {
      allow read: if request.auth != null;
      allow write: if isAdmin(); // Only Admins modify structure
    }
    
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if isAdmin(); // Only Admin can change roles
    }
    
    match /taxonomies/{doc} {
      allow read, create: if request.auth != null;
      allow delete: if isAdmin(); // Planners cannot delete history
    }
  }
}
```

---

## 4. Migration Plan

1.  **Phase 1 (Current)**: LocalStorage + Mock Auth.
2.  **Phase 2 (Next)**: Hybrid.
    *   Initialize `db = getFirestore(app)` in `firebaseConfig.ts`.
    *   Create a `useFirestoreSync` hook to push LocalStorage data to Firestore once logged in.
3.  **Phase 3 (Final)**: Cloud First.
    *   Refactor `useTaxonomyStore` to fetch directly from Firestore.
    *   Remove `localStorage` logic.

## Recommendation for Next Steps
Since we successfully set up Google Auth, the logical next step is to **Initialize Firestore** in the project and create the **'Users' collection** so valid users can be persisted in the cloud instead of the browser.
